<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    
<head>
   
<title>Sprint1</title>
<link rel="stylesheet" type="text/css" href="../commons/resources/styles/templateISS.css">
<link rel="stylesheet" type="text/css" href="../commons/resources/styles/main.css">
<link rel="stylesheet" type="text/css" href="../commons/resources/styles/navbar.css">
<link rel="stylesheet" type="text/css" href="../commons/resources/styles/table.css">
<link rel="stylesheet" type="text/css" href="../commons/resources/styles/code.css">
<script type="text/javascript" src="../commons/resources/scripts/myScripts.js"></script>


</head>
    
<body>
<div id="top">
<h1>Cold Storage Service: Sprint1 <font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduzione</h2>
<div class="remark">
Sprint1 del progetto finale del corso di Ingegneria dei Sistemi Software M.<br>
In questa fase ci concentreremo sui requisiti riguardanti il core della logica di business del servizio da realizzare analizzati nello <a href="../sprint0/Sprint0_v1.html"><ksi>sprint0</ksi></a> con l'obiettivo di implementare un primo prototipo funzionante dell'applicazione.
</div>
</div>

<h2>Requisiti</h2>
<a href="../commons/html/TemaFinale23.html">TemaFinale23</a><br>
In particolare, ci concentreremo sull'analisi e progettazione delle entità coinvolte nella catena "richiesta di deposito - accettazione - azione di deposito".<br>
 




 
 

<h2 >Analisi dei requisiti</h2>
<h3>System abstract</h3>
Lo Sprint1 coinvolge i seguenti contesti:
<ul>
    <li>ColdStorageService</li>
    <li>DDR Robot</li>
    <li>ServiceAccesGUI</li>
</ul>
<br>
<img src="../sprint1/resources/imgs/terzoschemaSprint1.jpg" width="600"> <br>
Dato che siamo interessati ad analizzare solo il core-business del sistema, implementeremo la GUI come una semplice applicazione che simula l'interazione tra un camionista e il servizio.<br>
Inoltre non prenderemo in considerazione l'esistenza del raspberry e non implementeremo le funzionalità di stop/resume del transporttrolley, le quali verranno trattate nell'ultimo sprint.




<h3>Formalizzazione dei requisiti</h3>
Di seguito sono riportati gli elementi individuati nello sprint0 che sono coinvolti in questa fase.<br>
<h4 id="Entities">Entità</h4>
<table class="dictionary">
    <tr>
        <th>Entità</th>
        <th>Attvità</th>
        <th>Tipo</th>
        <th>Descrizione</th>
    </tr>
    <tr>
        <td>ColdStorageService</td>
        <td>Proattivo & Reattivo</td>
        <td>Attore</td>
        <td>Gestisce le richieste di fridgeTruck e gestice le azioni del Transport Trolley. Inoltre invia aggiornamenti agli Alarm Devices .</td>
    </tr>
    <tr>
        <td>basicRobot</td>
        <td>Reattivo</td>
        <td>Attore</td>
        <td>Entità che riceve comandi dal TransportTrolley e guida il DDR robot.</td>
    </tr>
    <tr>
        <td>transportTrolley</td>
        <td>Proattivo e Reattivo</td>
        <td>Attore</td>
        <td>Entità principale del ColdStorage system, che si muove all'interno della Service Area ed esegue le azioni di trasporto.</td>
    </tr>
    <tr>
        <td>ServiceAcessGUI-simulator</td>
        <td>Reattivo</td>
        <td>Attore</td>
        <td>Entità che funge da simulatore di store request e di interazione tra camionista e servizio</td>
    </tr>
    
</table>


<h4 id="Data">Dati</h4>


<table class="dictionary">
    <tr>
        <td>Dati</td>
        <td>Tipo</td>
        <td>Descrizione</td>
    </tr>
    <tr>
        <td>truckLoad</td>
        <td>variabile intera > 0</td>
        <td>Indica il peso diverso di ogni food-load che il truckFridge vuole scaricare, espresso in KG.</td>
    </tr>

    <tr>
        <td>MAXW</td>
        <td>costante intera > 0</td>
        <td>Indica la quantità massima,espressa in KG, che il container della ColdRoom può dedicare alla conservazione del cibo . </td>
    </tr>

    <tr>
        <td>Ticket</td>
        <td>variabile intera > 0</td>
        <td>Viene generato dal servizio una volta che il driver della truckFridge ha inviato una <b>storerequest</b>.</td>
    </tr>
    <tr>
        <td>TruckTicket</td>
        <td>variabile intera > 0</td>
        <td>Si tratta dell'intero associato al precedente ticket generato, che risulta essenziale per il driver quando dovrà inserirlo al momento dell'arrivo presso la porta INDOOR. Questo numero è importante per verificare se il ticket è ancora valido o se è scaduto.</td>
    </tr>
    
    <tr>
        <td>TICKETTIME <br>(da inserire nel kotlin)</td>
        <td>variabile intera > 0</td>
        <td>Indica un tempo espresso in secondi, che il driver ha a disposizione, una volta che la ColdStorageService ha accettato la <b>storerequest</b> per recarsi alla porta INDOOR.</td>
    </tr>
    <tr>
        <td>RD</td>
        <td>costante intera > 0</td>
        <td>Lunghezza di ogni lato del TransportTrolley.</td>   
    </tr>
    <!--
    <tr>
        <td>DLIMT</td>
        <td>costante FLOAT</td>
        <td>Distanza limite entro il quale si attiva l'alarmDevice.</td>
    </tr>
    <tr>
        <td>MINT</td>
        <td>variabile FLOAT</td>
        <td>Intervallo di tempo espresso in msecs entro il quale il TransportTrolley non deve essere fermato se non è trascorso un certo periodo di tempo dal precedente stop. </td>
    </tr>

-->
    
</table>

<h4 id="Messages">Messaggi</h4>
<table class="dictionary">
    <tr>
        <td>Messaggio</td>
        <td>Tipo</td>
        <td>Mittente</td>
        <td>Destinatario</td>
        <td>Descrizione</td>
    </tr>
    <tr>
        <td>storerequest</td>
        <td>Richiesta</td>
        <td>Fridge truck driver</td>
        <td>ColdStorageService</td>
        <td>Chiede se il foodload di FW kg può essere scaricato nella ColdStorageService.</td>
    </tr>
    <tr>
        <td>loadaccepted</td>
        <td>Risposta</td>
        <td>ColdStorageService</td>
        <td>Fridge truck driver</td>
        <td>C'è abbastanza spazio per depositare il nuovo food-load.</td>
    </tr>
    <tr>
        <td>loadrejected</td>
        <td>Risposta</td>
        <td>ColdStorageService</td>
        <td>Fridge truck driver</td>
        <td>Non c'è abbastanza spazio per depositare il nuovo food-load.</td>
    </tr>
    <tr>
        <td>verifyticket</td>
        <td>Richiesta</td>
        <td>ServiceAccessGUI</td>
        <td>ColdStorageService</td>
        <td>Quando il Fridge truck driver usa la ServiceAcessGUI, inserisce il numero del ticket per verificare se la durata del ticket sia valida o sia scaduta.</td>
    </tr>
    <tr>
        <td>chargetaken</td>
        <td>Risposta</td>
        <td>ColdStorageService</td>
        <td>ServiceAccessGUI</td>
        <td>ColdStorageService ha validato il ticket, il TransportTrolley si avvicinerà a INDOOR, preleverà il food-load e il servizio invierà il messsaggio sulla ServiceAccessGUI utile al Fridge truck driver per liberare la porta INDOOR. </td>
            
        </td>
    </tr>
    <tr>
        <td>invalidticket</td>
        <td>Risposta</td>
        <td>ColdStorageService</td>
        <td>ServiceAccessGUI</td>
        <td>ColdStorageService ha elaborato che il ticket non è più valido/scaduto.</td>
    </tr>
     <!--<tr>
        <td>doJob</td>
        <td>Dispatch</td>
        <td>ColdStorageService</td>
        <td>TransportTrolley</td>
        <td>Il transport trolley è abilitato a svolgere una <b>Deposit Action</b> .</td>
    </tr>
    <tr>
        <td>stop</td>
        <td>Dispatch</td>
        <td>alarmDevice</td>
        <td>TransportTrolley</td>
        <td>Arresta il robot e impedisce di svolgere qualsiasi attività.</td>
    </tr>
    <tr>
        <td>resume</td>
        <td>Dispatch</td>
        <td>alarmDevice</td>
        <td>TransportTrolley</td>
        <td>Riprende l'attività del robot.</td>
    </tr>
    <tr>
        <td>updateled</td>
        <td>Dispatch</td>
        <td>TransportTrolley</td>
        <td>Warning Device</td>
        <td>Aggiorna lo stato del led.</td>

    </tr>
     -->
    
    </table>
	
<br/><br/> 	
</div>  

<h3>Componenti della Core-Business</h3>
<h4>ServiceAccessGUI-Simulator</h4>
Componente che simula l'interazione tra i camionisti e il ColdStorageService inviando storerequest e verifyticket. <br>

<h4>ColdStorageService</h4>
Componente che implementa la logica di business della nostra applicazione.
<h5>Requisiti aggiuntivi</h5>
Il fridgeTruck deve andarsene il prima possibile e il tempo  per il ritiro dei rifiuti è sempre limitato e prevedibile, quindi:
<li>Se la ColdStorageService risponde con la <ksi>loadaccepted</ksi>allora il fridgeTruck-driver deve attendere il completamento del ritiro, e mandato via subito dopo.</li>
<li>Se la ColdStorageService risponde con un <ksi>loadrejected</ksi> allora il fridgeTruck-driver deve essere mandato via immediatamente.</li> 
<h5>Service Area</h5>
Date l'immagine e la descrizione della service area da parte del committente, si possono così sintetizzare gli elementi principali:<br>
<ul>
    <li>la stanza è di forma rettangolare</li>
    <li>la zona HOME è posta nell'angolo nord-ovest. Il robot si trova qui all'avvio dell'applicazione</li>
    <li>l'INDOOR è un'area sul lato opposto a HOME in cui il transport trolley deve recarsi ogni volta che un truck load è pronto a essere depositato</li>
    <li>la cold room è la cella frigorifera dove si depositano i carichi. E' accessibile tramite una porta sul lato rivolto verso l'INDOOR</li>
    <li>è presente un ostacolo in mezzo alla stanza</li>
</ul>
Grazie al software unibo.mapperQak23 fornito dal committente, è possibile ottenere una rappresentazione a griglia della service area, in cui ogni cella è localizzata tramite un sistema di coordinate (colonna,riga).<br>
Ogni cella è un quadrato di lato pari a RD e HOME si trova in posizione (0,0).<br>
La rappresentazione ottenuta è la seguente:<br>
<br>
<img src="../sprint0/modello_servicearea.png" width="350" ><br>
<div class="remark">
    La posizione <ksi>HOME</ksi> è rappresentata dalla cella (0,0), <ksi>INDOOR</ksi> occupa le celle (0,4) e (1,4), <KSI>PORT</KSI> occupa le celle (4,3) e (5,3).
    </div>
Legenda:
<br>
<ul>
    <li>r: posizione corrente del robot</li>
    <li>1: celle libere</li>
    <li>X: celle occupate da un ostacolo/cold room</li>
</ul>
<br>





<h4>TransportTrolley &  BasicRobot</h4>
Il TransportTrolley e il DDR Robot sono gli elementi del sistema che effettuano le operazioni di stoccaggio:

    <li>pickup</li>
    <li>transport</li>
    <li>stock</li>
In particolare, il transportTrolley interagisce con la ColdStorageService e invia comandi al DDR Robot, che esegue le varie operazioni di stoccaggio.
<br>Il Robot che utilizzeremo per il progetto sarà virtuale ed eseguirà quindi all'interno di un ambiente virtuale.








<!-- ------------------ANALISI DEL PROBLEMA---------------------- -->
<!-- ------------------------------------------------------------ -->
<!-- ------------------------------------------------------------ -->
<h2>Analisi del Problema</h2>



<h3>Core-Business Software</h3>
<h4>ServiceAccesGUI-Simulator</h4>
Il simulatore sarà realizzato come un QAK actor in grado di generare storerequest consecutive, intervallate da richieste di tipo verifyticket.<br>
In questo modo potremo testare il funzionamento della business logic della nostra applicazione senza dover sviluppare una GUI stand alone apposita.<br>
L'analisi e il progetto di quest'ultima verranno affrontati nello sprint3.<br>




<h4>ColdStorageService</h4>
Questo è il componente centrale del sistema e dovrà occuparsi di varie operazioni (interfacciamento con GUI e raspberry, generazione e gestione dei ticket, controllo del transporttrolley...).<br>
Per questo motivo risulta vantaggioso scomporlo in più sotto-componenti, in primis per rispettare il principio di singola responsabilità e, in secondo luogo, per rendere l'applicazione più modulare e migliorarne reusability e maintainability in visione di futuri aggiornamenti.<br>
Ogni parte sarà implementata come un attore QAK poichè dovrà essere in grado sia di ricevere che inviare messaggi.<br>
<div class="remark">
Una prima suddivisione può comprendere i seguenti attori:
<ul>
    <li>ColdStorageService</li>si occupa di interfacciarsi con gli altri contesti e di inoltrare eventuali richieste ai giusti attori. E' quindi l'access point dell'applicazione
    <li>Transporttrolley</li>rappresenta l'astrazione logica del DDR robot, si occupa di inoltrare i comandi di movimento al basic robot e funge quindi da unità di controllo di alto livello
    <li>Ticketmanager</li>si occupa della generazione, memorizzazione e verifa dei ticket legati a ogni storerequest andata a buon fine
    <li>Coldroommanager</li>si occupa di gestire i contatori della cold room ed, eventualmente, svuotarla periodicamente
</ul>
</div>
<h4>Service area</h4>
Nonostante la zona INDOOR e la porta della cold room occupino due celle ciascuna nel nostro modello di service area, abbiamo deciso di scegliere soltanto una delle due come destinazione dei movimenti del DDR robot, in modo da poterle cablare direttamente nel codice.<br>
Questo per tre motivi principali:
<ul>
    <li>semplicità e velocità di implementazione</li>
    <li>non prevediamo che la forma della stanza possa cambiare in futuro</li>
    <li>il basic robot è già dotato di un componente in grado di calcolare il miglior path dato un punto di partenza e un goal. Tenere conto del fatto che il goal potrebbe essere composto da due posizioni invece di una non inficia considerevolmente l'efficienza dei movimenti del robot</li>
</ul>
<br>
<div class="remark">
    In alternativa si potrebbe estendere la libreria unibo.planner23-1.0 in modo da rappresentare le celle corrispondenti all'INDOOR e alla porta con degli specifici nomi logici invece delle semplici coordinate (x,y).<br>
    Valuteremo se implementare questa soluzione in uno sprint futuro.
</div>

<h4>DDR robot</h4>
Il DDR robot è l'end point finale dell'applicazione: è il componente fisico che effettuerà i movimenti e le azioni di deposito all'interno della service area.<br>
Lo si può pensare come un robot fisico reale o come, nel caso di questo progetto, un robot virtuale.<br>
Infatti il committente ci ha fornito, oltre al software già citato, anche un'implementazione di tale robot virtuale, compatibile con il modello Qak a scambio di messaggi .<br>
Il progetto unibo.basicrobot23 rappresenta lo strato software da interporre tra la nostra applicazione e l'implementazione del robot ed è esso stesso basato sul modello qak, quindi facilmente integrabile al nostro sistema.<br>
Il transporttrolley si occuperà di comunicare al basic robot i movimenti da effettuare.<br>
Una caratteristica importante del basic robot è la sua completa indipendenza dalla realizzazione sottostante del DDR robot, per questo motivo in futuro sarà possibile sostituire il virtual robot con uno fisico senza cambiare nulla del codice della nostra applicazione.




<div style="background-color:rgba(137, 129, 186, 0.9); width:60%;text-align:left;color:white">
By
 andrea.isernio@studio.unibo.it & fabio.gentili3@studio.unibo.it <br>
<br>
GIT repo: <a href="https://github.com/FabioGentili99/ColdStorageService">https://github.com/FabioGentili99/ColdStorageService </a>

</div> 
</body>
</html>